<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gif'r</title>
  <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
  <link rel="stylesheet" href="bulma.min.css">
  <!-- <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap&family=Leckerli+One&family=Noto+Serif" rel="stylesheet"> -->
  <style>
    .hidden {
      display: none !important;
    }
    .handle {
      user-select: none;
    }
    .p-0 { padding: 0px; }
    .pt-1 { padding-top: 0.5rem; }
    .pt-2 { padding-top: 1rem; }
    .pb-2 { padding-bottom: 1rem; }

    .mb-2 { margin-bottom: 1rem; }

    .text-center { text-align: center; }

    .square-edges, #playback-controls .button {
      border-radius: 0;
    }

    .is-danger {
      background-color: #f14668;
      color: #fff;
    }

    #canvas-preview-section canvas {
      margin-right: 0.25rem;
    }
  </style>
  <script src="https://kit.fontawesome.com/e489190e54.js" crossorigin="anonymous"></script>
  <script src="gif.js"></script>
  <script src="gif.worker.js"></script>
  <script type="text/javascript">

    window.drawState = {};

    function find(selector) {
      return document.querySelector(selector);
    }

    function resetCanvas(canvas) {
      const ctx = canvas.getContext("2d");
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawStrokeOntoCanvas(canvas, previousPosition, currentPosition, drawOptions = {}) {
      if (!(canvas && previousPosition && currentPosition)) {
        console.error("not enuff stough");
        return;
      }

      const ctx = canvas.getContext("2d");

      ctx.globalCompositeOperation = "source-over"; // layer on top

      ctx.strokeStyle = drawOptions.penColour || 'orange';
      ctx.lineWidth = 10;

      ctx.beginPath();
      ctx.moveTo(previousPosition.x, previousPosition.y);
      ctx.lineTo(currentPosition.x, currentPosition.y);
      ctx.stroke();
    }

    // Cool brushy effect
    function initBrushyDrawHandlers(canvas) {
      canvas.on = on;

      canvas.on("touchstart", function(e) {
        drawState.penDown = true;
        drawState.previousPosition = getPositionForTouchMove(this, e);
        console.log(e, drawState);
      });

      canvas.on("touchend", e => {
        drawState.penDown = false;
        drawState.previousPosition = null;
        console.log(e, drawState);
      });

      canvas.on("touchmove", function(e) {
        e.preventDefault();
        if (!drawState.penDown) return;

        const currentPosition = getPositionForTouchMove(this, e);
        drawStrokeOntoCanvas(this, drawState.previousPosition, currentPosition, { penColour: drawState.penColour });

        drawState.previousPosition = currentPosition;
        console.log(drawState.previousPosition.x, drawState.previousPosition.y);
      });
    }

    function initDrawHandlers(canvas) {
      let ctx;

      canvas.on = on;

      canvas.on("touchstart", function(e) {
        drawState.penDown = true;
        drawState.previousPosition = getPositionForTouchMove(this, e);

        ctx = canvas.getContext("2d");
        ctx.strokeStyle = drawState.penColour || "orange";
        ctx.fillStyle = drawState.penColour || "orange"; // for the starting and ending dots
        ctx.lineWidth = drawState.lineWidth || 15;
        ctx.lineJoin = "round";

        ctx.beginPath();
        ctx.arc(drawState.previousPosition.x, drawState.previousPosition.y, ctx.lineWidth / 2, 0, 2 * Math.PI);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(drawState.previousPosition.x, drawState.previousPosition.y);
      });

      canvas.on("touchend", function(e) {
        ctx.beginPath();
        ctx.arc(drawState.previousPosition.x, drawState.previousPosition.y, ctx.lineWidth / 2, 0, 2 * Math.PI);
        ctx.fill();

        drawState.penDown = false;
        drawState.previousPosition = null;
      });

      canvas.on("touchmove", function(e) {
        e.preventDefault();

        if (!drawState.penDown) return;

        const currentPosition = getPositionForTouchMove(this, e);
        drawState.previousPosition = currentPosition;

        ctx.lineTo(drawState.previousPosition.x, drawState.previousPosition.y);
        ctx.stroke();
      });
    }

    function on(eventName, handler) {
      this.addEventListener(eventName, handler);
    }

    function setPenColour(colour) {
      drawState.penColour = colour;
      console.log(drawState);
    }

    function initScratchCanvas() {
      const mainCanvas = find("#main-canvas");
      const canvas = document.createElement("canvas");
      canvas.width = mainCanvas.width, canvas.height = mainCanvas.height;
      return canvas;
    }

    function addFrame() {
      const mainCanvas = find("#main-canvas");
      const mainCanvasImageData = mainCanvas.getContext("2d").getImageData(0, 0, mainCanvas.width, mainCanvas.height);
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 50, canvas.height = 50;

      let scratchCanvas = initScratchCanvas();
      let scratchCtx = scratchCanvas.getContext("2d");
      scratchCtx.putImageData(mainCanvasImageData, 0, 0);

      ctx.scale(canvas.width / mainCanvas.width, canvas.height / mainCanvas.height);
      ctx.drawImage(scratchCanvas, 0, 0);

      console.log("addFrame", canvas);
      find("#canvas-preview-section").appendChild(canvas);

      window.frameData[window.frameData.frameCount] = { imageData: mainCanvasImageData, delay: 1 };
      window.frameData.frameCount++;

      canvas.scrollIntoView({ behavior: "smooth" });
    }

    function generateGif() {
      console.error("DID NOT IMPLEMENT");
    }

    function generateGif() {
      const gif = new GIF({
        workers: 2,
        quality: 10
      });

      for (let i = 0; i < window.frameData.frameCount; i++) {
        if (!window.frameData[i]) continue;
        const currentFrame = window.frameData[i];
        console.log("currentFrame", currentFrame);
        gif.addFrame(currentFrame.imageData, { copy: true, delay: currentFrame.delay * 10 });
      }

      gif.on('finished', function(blob) {
        const url = URL.createObjectURL(blob);
        console.log("gif ready:", url);
        window.lastRender = blob;

        const renderedImg = find("#output-gif");
        renderedImg.src = url;
        renderedImg.crossOrigin = "Anonymous";

        makeVisible(find("#render-section"));
        setTimeout(() => renderedImg.scrollIntoView({ behavior: "smooth" }), 500);
      });

      console.log("rendering...");
      gif.render();
    }

    function getPositionForTouchMove(canvas, event) {
      const touchEvent = event.targetTouches[0];
      const box = canvas.getBoundingClientRect();

      return {
        x: touchEvent.clientX - box.left,
        y: touchEvent.clientY - box.top
      };
    }

    function makeVisible(element) {
      element.classList.remove("hidden");
    }

    document.addEventListener("DOMContentLoaded", () => {
      console.log("App Loaded");

      window.frameData = { frameCount: 0 };

      const containerWidth = find("#main-canvas-container").clientWidth;
      const canvas = find("#main-canvas");

      canvas.height = containerWidth, canvas.width = containerWidth;

      resetCanvas(canvas);
      initDrawHandlers(canvas);

      const colours = ["black", "grey", "white", "red", "orange", "yellow", "green", "deepskyblue", "blue", "purple", "pink", "saddlebrown"];
      find("#colour-palette").innerHTML = colours.map(c =>
        `<button class="button square-edges" id="colour-${c}" onclick="setPenColour('${c}')" style="background-color: ${c}; border: none;">&nbsp;</button>`
      ).join("");

      find("#add-frame").addEventListener("click", e => addFrame());
      find("#generate-gif").addEventListener("click", e => generateGif());
    });
  </script>
</head>
<body>

  <!-- <nav class="navbar _is-primary" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">
        <img src="favicon.png" alt="Gif'r" >
        <span style="font-family: 'Noto Serif', serif; margin-left: 0.5rem;">Gif Tools</span>
      </a>

      <a class="navbar-item" href="/">
        Gif Editor
      </a>

      <a class="navbar-item" href="/diy.html">
        Gif Sketchpad
      </a>
    </div>
  </nav> -->
`
  <section class="hero is-primary">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">Draw something!</h1>
        <div id="canvas-preview-section" class="mb-2" style="overflow-x: auto; display: flex; min-height: 50px;"></div>

        <div id="main-canvas-container">
          <canvas id="main-canvas" width="100%" height="100%">
        </div>

        <div class="buttons has-addons pt-1" id="colour-palette" style="justify-content: center;">
        </div>

        <div class="buttons has-addons is-fullwidth">
          <button class="button" id="add-frame">Add Frame</button>
          <button class="button" id="generate-gif">Render Gif</button>
        </div>
      </div>
    </div>
  </section>

  <section class="section hidden" id="render-section">
    <div class="container">
      <h1 class="title">You GIF is ready!</h1>
      <h2 class="subtitle">
        You have to <strong>Save the Image</strong>, you won't be able to hot link it.
      </h2>
      <div>
        <img id="output-gif">
      </div>
    </div>
  </section>
</body>
